这个主要是测试类的static成员变量初始化是在什么时候发生的，理论上是在main之前，但是前提是这个内容被最终的可执行文件正确的链接了。编译器开O2优化的时候会跳过一些没被显式使用的链接。
所以这里构建了个demo，A是全局类负责存储被注册的内容，B是可复制粘贴扩展的子项类，通过对B的static成员变量进行初始化（函数）实现在A内注册的效果，先把A和B分别编译，然后归档成静态库。
main文件内只引用了A，没直接用B，所以最后编译main的时候不会链接B.o，进而导致B.o的成员变量初始化不会被执行。这点通过main_not_use_b编译出来的main_not_use_b可以验证
而在main中只用普通的unique_ptr<B>，但是不真正执行B的函数也不行，也会被编译器优化，因为没使用这个变量，构造函数也没做有意义的事，所以也不会链接B.o，也就不会进行全局初始化B的成员变量。但是如果显式调用B的成员函数一次，就可以了。
vnetcontroller代码可行的原因是，他的B类是有虚函数的子类，每当类有虚函数的时候会在.cpp内定义vtable，此时就必须对B.o进行链接，也就能进行static成员变量的全局初始化了。（这里注意，只是把B的析构函数做成virtual = default，也不行，也会被编译器优化）这里具体的链接细节就没细研究了，涉及对变量进行构造的时候，vtable的查找、保存之类的

总结，标准的实现方式，还是应该main.cpp来调用B的注册，而不是这种奇技淫巧，很脆弱容易被破坏。
